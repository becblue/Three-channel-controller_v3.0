#include "oled_display.h"
#include "i2c.h" // 假设CubeMX已配置I2C并生成i2c.h
#include <string.h>
#include <stdio.h>  // 为snprintf函数添加
#include "log_system.h"  // 包含日志系统，用于健康度显示

// 外部公司LOGO数据声明
extern const unsigned char gImage_minyerlogo[411];

// Flash健康度警告显示变量
uint8_t oled_show_flash_warning = 0;

// SSD1309 I2C地址（7位地址0x3C，发送时自动左移1位变成0x78）
#define OLED_I2C_ADDR 0x78  // 可能需要尝试 0x7A (0x3D<<1)

// 显存缓存
static uint8_t OLED_GRAM[OLED_HEIGHT/8][OLED_WIDTH];

// 显示内容缓存，用于智能刷新
static char g_display_cache[DISPLAY_CACHE_SIZE];
static uint8_t g_cache_valid = 0;  // 缓存是否有效的标志

// 脏区管理相关变量
static DirtyRegion_t g_dirty_regions[OLED_DIRTY_REGION_MAX];
static uint8_t g_dirty_count = 0;
static uint8_t g_prev_gram[8][128];  // 上一帧的GRAM备份，用于脏区检测

// 测试OLED I2C连接并尝试不同地址
uint8_t OLED_TestConnection(void)
{
    uint8_t test_addresses[] = {0x78, 0x7A, 0x3C << 1, 0x3D << 1}; // 常见OLED地址
    
    for(int i = 0; i < 4; i++) {
        if(HAL_I2C_IsDeviceReady(&hi2c1, test_addresses[i], 3, 100) == HAL_OK) {
            // 找到有效地址，测试写入命令
            uint8_t test_cmd = 0xAE; // 关闭显示命令
            if(HAL_I2C_Mem_Write(&hi2c1, test_addresses[i], 0x00, I2C_MEMADD_SIZE_8BIT, &test_cmd, 1, 100) == HAL_OK) {
                return test_addresses[i]; // 返回找到的有效地址
            }
        }
    }
    return 0; // 未找到有效地址
}

// 发送命令到OLED
static void OLED_WriteCmd(uint8_t cmd)
{
    // HAL库I2C发送命令
    HAL_I2C_Mem_Write(&hi2c1, OLED_I2C_ADDR, 0x00, I2C_MEMADD_SIZE_8BIT, &cmd, 1, 10);
}

// 发送数据到OLED
static void OLED_WriteData(uint8_t data)
{
    HAL_I2C_Mem_Write(&hi2c1, OLED_I2C_ADDR, 0x40, I2C_MEMADD_SIZE_8BIT, &data, 1, 10);
}

// OLED硬件初始化 - 基于SSD1309技术文档的标准初始化序列
void OLED_Init(void)
{
    HAL_Delay(100); // 上电延时
    
    // SSD1309标准初始化序列
    OLED_WriteCmd(0xAE); // 关闭显示
    OLED_WriteCmd(0xD5); OLED_WriteCmd(0x80); // 设置显示时钟分频比/振荡器频率
    OLED_WriteCmd(0xA8); OLED_WriteCmd(0x3F); // 设置多路复用率(1-64)
    OLED_WriteCmd(0xD3); OLED_WriteCmd(0x00); // 设置显示偏移
    OLED_WriteCmd(0x40); // 设置显示开始行 [5:0]
    OLED_WriteCmd(0x8D); OLED_WriteCmd(0x14); // 使能电荷泵
    OLED_WriteCmd(0x20); OLED_WriteCmd(0x00); // 设置内存地址模式：水平地址模式
    OLED_WriteCmd(0xA1); // 段重定向设置，bit0:0,0->0;1,0->127;
    OLED_WriteCmd(0xC8); // 设置COM扫描方向;bit3:0,普通模式;1,重定义模式 COM[N-1]->COM0;N:驱动路数
    OLED_WriteCmd(0xDA); OLED_WriteCmd(0x12); // 设置COM硬件引脚配置
    OLED_WriteCmd(0x81); OLED_WriteCmd(0xCF); // 设置对比度控制
    OLED_WriteCmd(0xD9); OLED_WriteCmd(0xF1); // 设置预充电周期
    OLED_WriteCmd(0xDB); OLED_WriteCmd(0x40); // 设置VCOMH取消选择级别
    OLED_WriteCmd(0xA4); // 全局显示开启;bit0:1,开启;0,关闭;(白屏/黑屏)
    OLED_WriteCmd(0xA6); // 设置显示方式;bit0:1,反相显示;0,正常显示
    HAL_Delay(100);
    OLED_WriteCmd(0xAF); // 开启显示
    
    OLED_Clear(); // 清屏
}

// 刷新显存到OLED
void OLED_Refresh(void)
{
    for(uint8_t page=0; page<8; page++)
    {
        OLED_WriteCmd(0xB0 + page); // 设置页地址
        OLED_WriteCmd(0x00);        // 设置列低地址
        OLED_WriteCmd(0x10);        // 设置列高地址
        HAL_I2C_Mem_Write(&hi2c1, OLED_I2C_ADDR, 0x40, I2C_MEMADD_SIZE_8BIT, OLED_GRAM[page], OLED_WIDTH, 100);
    }
}

// 清屏
void OLED_Clear(void)
{
    memset(OLED_GRAM, 0, sizeof(OLED_GRAM));
    OLED_Refresh();
}

// ================== 6x8 英文字库（ASCII 0x20~0x7E） ==================
// 每个字符6字节，纵向排列，低位在上
static const uint8_t Font6x8[][6] = {
    {0x00,0x00,0x00,0x00,0x00,0x00}, // 0x20 ' '
    {0x00,0x00,0x5F,0x00,0x00,0x00}, // 0x21 '!'
    {0x00,0x07,0x00,0x07,0x00,0x00}, // 0x22 '"'
    {0x14,0x7F,0x14,0x7F,0x14,0x00}, // 0x23 '#'
    {0x24,0x2A,0x7F,0x2A,0x12,0x00}, // 0x24 '$'
    {0x23,0x13,0x08,0x64,0x62,0x00}, // 0x25 '%'
    {0x36,0x49,0x55,0x22,0x50,0x00}, // 0x26 '&'
    {0x00,0x05,0x03,0x00,0x00,0x00}, // 0x27 '''
    {0x00,0x1C,0x22,0x41,0x00,0x00}, // 0x28 '('
    {0x00,0x41,0x22,0x1C,0x00,0x00}, // 0x29 ')'
    {0x14,0x08,0x3E,0x08,0x14,0x00}, // 0x2A '*'
    {0x08,0x08,0x3E,0x08,0x08,0x00}, // 0x2B '+' 
    {0x00,0x50,0x30,0x00,0x00,0x00}, // 0x2C ','
    {0x08,0x08,0x08,0x08,0x08,0x00}, // 0x2D '-'
    {0x00,0x60,0x60,0x00,0x00,0x00}, // 0x2E '.'
    {0x20,0x10,0x08,0x04,0x02,0x00}, // 0x2F '/'
    {0x3E,0x51,0x49,0x45,0x3E,0x00}, // 0x30 '0'
    {0x00,0x42,0x7F,0x40,0x00,0x00}, // 0x31 '1'
    {0x42,0x61,0x51,0x49,0x46,0x00}, // 0x32 '2'
    {0x21,0x41,0x45,0x4B,0x31,0x00}, // 0x33 '3'
    {0x18,0x14,0x12,0x7F,0x10,0x00}, // 0x34 '4'
    {0x27,0x45,0x45,0x45,0x39,0x00}, // 0x35 '5'
    {0x3C,0x4A,0x49,0x49,0x30,0x00}, // 0x36 '6'
    {0x01,0x71,0x09,0x05,0x03,0x00}, // 0x37 '7'
    {0x36,0x49,0x49,0x49,0x36,0x00}, // 0x38 '8'
    {0x06,0x49,0x49,0x29,0x1E,0x00}, // 0x39 '9'
    {0x00,0x36,0x36,0x00,0x00,0x00}, // 0x3A ':'
    {0x00,0x56,0x36,0x00,0x00,0x00}, // 0x3B ';'
    {0x08,0x14,0x22,0x41,0x00,0x00}, // 0x3C '<'
    {0x14,0x14,0x14,0x14,0x14,0x00}, // 0x3D '='
    {0x00,0x41,0x22,0x14,0x08,0x00}, // 0x3E '>'
    {0x02,0x01,0x51,0x09,0x06,0x00}, // 0x3F '?'
    {0x32,0x49,0x79,0x41,0x3E,0x00}, // 0x40 '@'
    {0x7E,0x11,0x11,0x11,0x7E,0x00}, // 0x41 'A'
    {0x7F,0x49,0x49,0x49,0x36,0x00}, // 0x42 'B'
    {0x3E,0x41,0x41,0x41,0x22,0x00}, // 0x43 'C'
    {0x7F,0x41,0x41,0x22,0x1C,0x00}, // 0x44 'D'
    {0x7F,0x49,0x49,0x49,0x41,0x00}, // 0x45 'E'
    {0x7F,0x09,0x09,0x09,0x01,0x00}, // 0x46 'F'
    {0x3E,0x41,0x49,0x49,0x7A,0x00}, // 0x47 'G'
    {0x7F,0x08,0x08,0x08,0x7F,0x00}, // 0x48 'H'
    {0x00,0x41,0x7F,0x41,0x00,0x00}, // 0x49 'I'
    {0x20,0x40,0x41,0x3F,0x01,0x00}, // 0x4A 'J'
    {0x7F,0x08,0x14,0x22,0x41,0x00}, // 0x4B 'K'
    {0x7F,0x40,0x40,0x40,0x40,0x00}, // 0x4C 'L'
    {0x7F,0x02,0x0C,0x02,0x7F,0x00}, // 0x4D 'M'
    {0x7F,0x04,0x08,0x10,0x7F,0x00}, // 0x4E 'N'
    {0x3E,0x41,0x41,0x41,0x3E,0x00}, // 0x4F 'O'
    {0x7F,0x09,0x09,0x09,0x06,0x00}, // 0x50 'P'
    {0x3E,0x41,0x51,0x21,0x5E,0x00}, // 0x51 'Q'
    {0x7F,0x09,0x19,0x29,0x46,0x00}, // 0x52 'R'
    {0x46,0x49,0x49,0x49,0x31,0x00}, // 0x53 'S'
    {0x01,0x01,0x7F,0x01,0x01,0x00}, // 0x54 'T'
    {0x3F,0x40,0x40,0x40,0x3F,0x00}, // 0x55 'U'
    {0x1F,0x20,0x40,0x20,0x1F,0x00}, // 0x56 'V'
    {0x3F,0x40,0x38,0x40,0x3F,0x00}, // 0x57 'W'
    {0x63,0x14,0x08,0x14,0x63,0x00}, // 0x58 'X'
    {0x07,0x08,0x70,0x08,0x07,0x00}, // 0x59 'Y'
    {0x61,0x51,0x49,0x45,0x43,0x00}, // 0x5A 'Z'
    {0x00,0x08,0x36,0x41,0x00,0x00}, // 0x5B '['
    {0x00,0x00,0x7F,0x00,0x00,0x00}, // 0x5C '\'
    {0x00,0x41,0x36,0x08,0x00,0x00}, // 0x5D ']'
    {0x04,0x02,0x01,0x02,0x04,0x00}, // 0x5E '^'
    {0x40,0x40,0x40,0x40,0x40,0x00}, // 0x5F '_'
    {0x00,0x01,0x02,0x04,0x00,0x00}, // 0x60 '`'
    {0x20,0x54,0x54,0x54,0x78,0x00}, // 0x61 'a'
    {0x7F,0x48,0x44,0x44,0x38,0x00}, // 0x62 'b'
    {0x38,0x44,0x44,0x44,0x20,0x00}, // 0x63 'c'
    {0x38,0x44,0x44,0x48,0x7F,0x00}, // 0x64 'd'
    {0x38,0x54,0x54,0x54,0x18,0x00}, // 0x65 'e'
    {0x08,0x7E,0x09,0x01,0x02,0x00}, // 0x66 'f'
    {0x0C,0x52,0x52,0x52,0x3E,0x00}, // 0x67 'g'
    {0x7F,0x08,0x04,0x04,0x78,0x00}, // 0x68 'h'
    {0x00,0x44,0x7D,0x40,0x00,0x00}, // 0x69 'i'
    {0x20,0x40,0x44,0x3D,0x00,0x00}, // 0x6A 'j'
    {0x7F,0x10,0x28,0x44,0x00,0x00}, // 0x6B 'k'
    {0x00,0x41,0x7F,0x40,0x00,0x00}, // 0x6C 'l'
    {0x7C,0x04,0x18,0x04,0x78,0x00}, // 0x6D 'm'
    {0x7C,0x08,0x04,0x04,0x78,0x00}, // 0x6E 'n'
    {0x38,0x44,0x44,0x44,0x38,0x00}, // 0x6F 'o'
    {0x7C,0x14,0x14,0x14,0x08,0x00}, // 0x70 'p'
    {0x08,0x14,0x14,0x18,0x7C,0x00}, // 0x71 'q'
    {0x7C,0x08,0x04,0x04,0x08,0x00}, // 0x72 'r'
    {0x48,0x54,0x54,0x54,0x20,0x00}, // 0x73 's'
    {0x04,0x3F,0x44,0x40,0x20,0x00}, // 0x74 't'
    {0x3C,0x40,0x40,0x20,0x7C,0x00}, // 0x75 'u'
    {0x1C,0x20,0x40,0x20,0x1C,0x00}, // 0x76 'v'
    {0x3C,0x40,0x30,0x40,0x3C,0x00}, // 0x77 'w'
    {0x44,0x28,0x10,0x28,0x44,0x00}, // 0x78 'x'
    {0x0C,0x50,0x50,0x50,0x3C,0x00}, // 0x79 'y'
    {0x44,0x64,0x54,0x4C,0x44,0x00}, // 0x7A 'z'
    {0x00,0x08,0x36,0x41,0x00,0x00}, // 0x7B '{'
    {0x00,0x00,0x7F,0x00,0x00,0x00}, // 0x7C '|'
    {0x00,0x41,0x36,0x08,0x00,0x00}, // 0x7D '}'
    {0x10,0x08,0x08,0x10,0x08,0x00}, // 0x7E '~'
};

// ================== 8x16 英文字库（ASCII 0x20~0x7E） ==================
// 每个字符16字节，前8字节为上半部分，后8字节为下半部分
static const uint8_t Font8x16[][16] = {
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*" ",0*/
{0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x00,0x00,0x00,0x00},/*"!",1*/
{0x00,0x10,0x0C,0x02,0x10,0x0C,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*""",2*/
{0x00,0x40,0xC0,0x78,0x40,0xC0,0x78,0x00,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x00},/*"#",3*/
{0x00,0x70,0x88,0x88,0xFC,0x08,0x30,0x00,0x00,0x18,0x20,0x20,0xFF,0x21,0x1E,0x00},/*"$",4*/
{0xF0,0x08,0xF0,0x80,0x60,0x18,0x00,0x00,0x00,0x31,0x0C,0x03,0x1E,0x21,0x1E,0x00},/*"%",5*/
{0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x2C,0x19,0x27,0x21,0x10},/*"&",6*/
{0x00,0x12,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"'",7*/
{0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00},/*"(",8*/
{0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00},/*")",9*/
{0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00},/*"*",10*/
{0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x0F,0x01,0x01,0x01},/*"+",11*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x90,0x70,0x00,0x00,0x00,0x00,0x00},/*",",12*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x00},/*"-",13*/
{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00},/*".",14*/
{0x00,0x00,0x00,0x00,0xC0,0x38,0x04,0x00,0x00,0x60,0x18,0x07,0x00,0x00,0x00,0x00},/*"/",15*/
{0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00},/*"0",16*/
{0x00,0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00},/*"1",17*/
{0x00,0x70,0x08,0x08,0x08,0x08,0xF0,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00},/*"2",18*/
{0x00,0x30,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x18,0x20,0x21,0x21,0x22,0x1C,0x00},/*"3",19*/
{0x00,0x00,0x80,0x40,0x30,0xF8,0x00,0x00,0x00,0x06,0x05,0x24,0x24,0x3F,0x24,0x24},/*"4",20*/
{0x00,0xF8,0x88,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x20,0x20,0x20,0x11,0x0E,0x00},/*"5",21*/
{0x00,0xE0,0x10,0x88,0x88,0x90,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x20,0x1F,0x00},/*"6",22*/
{0x00,0x18,0x08,0x08,0x88,0x68,0x18,0x00,0x00,0x00,0x00,0x3E,0x01,0x00,0x00,0x00},/*"7",23*/
{0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00},/*"8",24*/
{0x00,0xF0,0x08,0x08,0x08,0x10,0xE0,0x00,0x00,0x01,0x12,0x22,0x22,0x11,0x0F,0x00},/*"9",25*/
{0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00},/*":",26*/
{0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x00,0x00,0x00,0x00},/*";",27*/
{0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00},/*"<",28*/
{0x00,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x00,0x02,0x02,0x02,0x02,0x02,0x02,0x00},/*"=",29*/
{0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00},/*">",30*/
{0x00,0x70,0x48,0x08,0x08,0x88,0x70,0x00,0x00,0x00,0x00,0x30,0x37,0x00,0x00,0x00},/*"?",31*/
{0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x28,0x2F,0x28,0x17,0x00},/*"@",32*/
{0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20},/*"A",33*/
{0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00},/*"B",34*/
{0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00},/*"C",35*/
{0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00},/*"D",36*/
{0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00},/*"E",37*/
{0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00},/*"F",38*/
{0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00},/*"G",39*/
{0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20},/*"H",40*/
{0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"I",41*/
{0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00},/*"J",42*/
{0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00},/*"K",43*/
{0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00},/*"L",44*/
{0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x01,0x3E,0x01,0x3F,0x20,0x00},/*"M",45*/
{0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00},/*"N",46*/
{0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00},/*"O",47*/
{0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00},/*"P",48*/
{0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x28,0x28,0x30,0x50,0x4F,0x00},/*"Q",49*/
{0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20},/*"R",50*/
{0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00},/*"S",51*/
{0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"T",52*/
{0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00},/*"U",53*/
{0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00},/*"V",54*/
{0x08,0xF8,0x00,0xF8,0x00,0xF8,0x08,0x00,0x00,0x03,0x3E,0x01,0x3E,0x03,0x00,0x00},/*"W",55*/
{0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20},/*"X",56*/
{0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00},/*"Y",57*/
{0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00},/*"Z",58*/
{0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40},/*"{",59*/
{0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00},/*"|",60*/
{0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00},/*"}",61*/
{0x00,0x06,0x01,0x03,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},/*"~",62*/
};

// ================== LOGO点阵数据（27行×16列，行扫描格式） ==================
// 来自Image2Lcd生成的gImage_logo数据，432字节 = 27行 × 16列
static const uint8_t logo_data[27][16] = {
    // 第1行
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 第2行
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 第3行
    {0x00,0x7F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC},
    // 第4行
    {0x01,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC},
    // 第5行
    {0x07,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC},
    // 第6行
    {0x0F,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFC},
    // 第7行
    {0x1F,0xFF,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 第8行
    {0x3F,0xFF,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 第9行
    {0x3F,0xFF,0x80,0x01,0xFF,0x01,0xE7,0x3C,0x3C,0x0F,0x0F,0x00,0x7F,0xF8,0x7F,0xC0},
    // 第10行
    {0x7F,0xFF,0x00,0x03,0xFF,0xC1,0xE7,0x7C,0x7C,0x0F,0x0F,0x00,0x7F,0xF8,0x7F,0xF8},
    // 第11行
    {0x7F,0xFF,0x00,0x03,0xFF,0xE1,0xE6,0x7C,0x7C,0x0F,0x0F,0x00,0x7F,0xF8,0x7F,0xF8},
    // 第12行
    {0x7F,0xFE,0x00,0x03,0xFF,0xE1,0xE6,0x78,0x78,0x1F,0x1F,0x00,0x7F,0xF8,0x7F,0xFC},
    // 第13行
    {0x7F,0xFE,0x00,0x03,0xC3,0xE3,0xE6,0x78,0x78,0x1F,0x1F,0x00,0x78,0x00,0xF8,0x7C},
    // 第14行
    {0xFF,0xFE,0x00,0x03,0xC1,0xE3,0xEE,0x78,0x78,0x1F,0x1F,0x00,0x78,0x00,0xF8,0x3C},
    // 第15行
    {0x7F,0xFE,0x00,0x03,0xC3,0xC3,0xE0,0x78,0x78,0x1E,0x1E,0x00,0xF8,0x00,0xF8,0x3C},
    // 第16行
    {0x7F,0xFE,0x00,0x03,0xFF,0xC3,0xC0,0xF8,0xFF,0xFE,0x1E,0x00,0xFF,0xF0,0xF0,0x7C},
    // 第17行
    {0x7F,0xFE,0x00,0x07,0xFF,0x03,0xC0,0xF8,0xFF,0xFE,0x1E,0x00,0xFF,0xF0,0xFF,0xF8},
    // 第18行
    {0x7F,0xFE,0x00,0x07,0xFF,0x83,0xC0,0xF8,0xFF,0xFE,0x1E,0x00,0xFF,0xE0,0xFF,0xF0},
    // 第19行
    {0x3F,0xFF,0x00,0x07,0xC7,0xC3,0xC0,0xF0,0xFF,0xFE,0x3E,0x00,0xFB,0xE0,0xFF,0xE0},
    // 第20行
    {0x3F,0xFF,0x80,0x07,0x83,0xC3,0xC0,0xF0,0xF0,0x3E,0x3E,0x00,0xF0,0x01,0xFF,0xC0},
    // 第21行
    {0x1F,0xFF,0x80,0x07,0x83,0xC3,0xC1,0xF0,0xF0,0x3E,0x3E,0x00,0xF0,0x01,0xF3,0xE0},
    // 第22行
    {0x0F,0xFF,0xE0,0x07,0x87,0xC3,0xF3,0xE0,0xF0,0x3C,0x3F,0xF9,0xFF,0xE1,0xF3,0xE0},
    // 第23行
    {0x07,0xFF,0xF8,0x07,0xFF,0xC3,0xFF,0xE1,0xF0,0x3C,0x3F,0xF9,0xFF,0xE1,0xE1,0xF0},
    // 第24行
    {0x01,0xFF,0xF8,0x0F,0xFF,0x81,0xFF,0xC1,0xF0,0x3C,0x3F,0xF9,0xFF,0xE1,0xE1,0xF0},
    // 第25行
    {0x00,0x7F,0xF8,0x0F,0xFF,0x00,0xFF,0x81,0xF0,0x7C,0x3F,0xF9,0xFF,0xE1,0xE0,0xF8},
    // 第26行
    {0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 第27行
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
};

// LOGO显示函数，将LOGO居中显示在OLED屏幕上
void OLED_ShowLogo(void)
{
    OLED_Clear(); // 清屏
    
    // 计算居中位置
    // LOGO尺寸: 27行 × 128像素, OLED尺寸: 64行 × 128像素
    // 水平居中: x_offset = (128 - 128) / 2 = 0 (LOGO宽度正好等于屏幕宽度)
    // 垂直居中: y_offset = (64 - 27) / 2 = 18 (向上偏移18像素)
    uint8_t x_offset = 0;   // 水平偏移（居中）
    uint8_t y_offset = 18;  // 垂直偏移（居中）
    
    // 逐行扫描LOGO数据，显示在居中位置
    for(uint8_t row = 0; row < 27; row++) {
        for(uint8_t col = 0; col < 16; col++) {
            uint8_t data = logo_data[row][col];
            // 每个字节表示8个像素点
            for(uint8_t bit = 0; bit < 8; bit++) {
                uint8_t x = x_offset + col * 8 + bit;  // 像素的x坐标（加上偏移）
                uint8_t y = y_offset + row;            // 像素的y坐标（加上偏移）
                
                if(x >= 128 || y >= 64) continue; // 超出屏幕范围不处理
                
                // 判断该像素是否点亮
                if(data & (0x80 >> bit)) {
                    // 点亮像素，设置GRAM对应位
                    OLED_GRAM[y / 8][x] |= (1 << (y % 8));
                } else {
                    // 熄灭像素，清除GRAM对应位
                    OLED_GRAM[y / 8][x] &= ~(1 << (y % 8));
                }
            }
        }
    }
    
    OLED_Refresh(); // 刷新显示
}

// 显示自检进度条（percent:0~100）
void OLED_ShowSelfTestBar(uint8_t percent)
{
    // 清除进度条区域（Y=32~39，8像素高）
    for(uint8_t y=32/8; y<=39/8; y++)
        for(uint8_t x=16; x<=111; x++)
            OLED_GRAM[y][x] = 0x00;
    
    // 绘制进度条边框（与新版本保持一致的修正版本）
    // 进度条外框：左上角(16,32) 到 右下角(111,39)，总宽度96像素，高度8像素
    
    // 绘制上下边框（水平线）
    for(uint8_t x=16; x<=111; x++)
    {
        OLED_GRAM[32/8][x] |= 0x01; // 上边框（Y=32对应第4页的最低位）
        OLED_GRAM[39/8][x] |= 0x80; // 下边框（Y=39对应第4页的最高位）
    }
    
    // 绘制左右边框（垂直线），注意避免角落重复
    for(uint8_t y=32/8; y<=39/8; y++)
    {
        OLED_GRAM[y][16] |= 0xFF; // 左边框（完整的垂直线）
        OLED_GRAM[y][111] |= 0xFF; // 右边框（完整的垂直线）
    }
    
    // 填充进度条
    uint8_t bar_len = (uint8_t)((percent * 94) / 100); // 进度条长度（94像素）
    for(uint8_t x=17; x<17+bar_len; x++)
        OLED_GRAM[33/8][x] = 0xFF;
    OLED_Refresh();
}

// 显示自检进度条和步骤描述（新增功能）
void OLED_ShowSelfTestBarWithStep(uint8_t percent, uint8_t step)
{
    // 清除整个显示区域
    // 文字区域：Y=16~23（第2页），间隔4行像素：Y=24~31，进度条区域：Y=32~39（第4页）
    for(uint8_t y=16/8; y<=39/8; y++)
        for(uint8_t x=0; x<128; x++)
            OLED_GRAM[y][x] = 0x00;
    
    // 定义英文步骤名称（简短版本）
    const char* step_names[] = {
        "",
        "Expected State",    // 期望状态识别 (14字符)
        "Relay Correct",     // 继电器纠错 (12字符) 
        "Contact Check",     // 接触器检查 (12字符)
        "Temp Safety"       // 温度安全检测 (11字符)
    };
    
    // 显示步骤描述（使用完整的页显示，确保文字完整）
    // 文字显示在第2页（Y=16~23），与进度条（Y=32~39）间隔8行像素
    if(step >= 1 && step <= 4) {
        const char* step_text = step_names[step];
        uint8_t str_len = strlen(step_text);
        uint8_t str_width = str_len * 6;  // 6x8字体宽度
        uint8_t center_x = (128 - str_width) / 2;  // 居中X坐标
        
        // 直接在第2页显示文字（Y=16~23对应页索引2）
        uint8_t text_page = 2;  // 第2页
        
        // 绘制步骤文字（使用标准6x8字体显示方式）
        for(uint8_t i = 0; i < str_len && (center_x + i * 6) < 128; i++) {
            char c = step_text[i];
            if(c >= 0x20 && c <= 0x7E) {
                uint8_t idx = c - 0x20;
                for(uint8_t j = 0; j < 6; j++) {
                    uint8_t x_pos = center_x + i * 6 + j;
                    if(x_pos < 128) {
                        // 直接写入字体数据到指定页
                        OLED_GRAM[text_page][x_pos] = Font6x8[idx][j];
                    }
                }
            }
        }
    }
    
    // 绘制进度条边框（Y=32~39，第4页）
    // 进度条外框：左上角(16,32) 到 右下角(111,39)，总宽度96像素，高度8像素
    
    // 绘制上下边框（水平线）
    for(uint8_t x=16; x<=111; x++)
    {
        OLED_GRAM[32/8][x] |= 0x01; // 上边框（Y=32对应第4页的最低位）
        OLED_GRAM[39/8][x] |= 0x80; // 下边框（Y=39对应第4页的最高位）
    }
    
    // 绘制左右边框（垂直线），注意避免角落重复
    for(uint8_t y=32/8; y<=39/8; y++)
    {
        OLED_GRAM[y][16] |= 0xFF; // 左边框（完整的垂直线）
        OLED_GRAM[y][111] |= 0xFF; // 右边框（完整的垂直线）
    }
    
    // 填充进度条
    uint8_t bar_len = (uint8_t)((percent * 94) / 100); // 进度条长度（94像素）
    for(uint8_t x=17; x<17+bar_len; x++)
        OLED_GRAM[33/8][x] = 0xFF;
    
    OLED_Refresh();
}

// 显示公司LOGO（小尺寸，用于自检界面）
void OLED_ShowCompanyLogo(void)
{
    // 第二阶段：解析真正的LOGO数据
    // 首先解析头部信息
    uint16_t logo_width = gImage_minyerlogo[2];   // 115像素
    uint16_t logo_height = gImage_minyerlogo[4];  // 27像素
    
    // 计算显示位置（在屏幕上方居中）
    uint8_t logo_x = (128 - logo_width) / 2;     // 水平居中，约6像素
    uint8_t logo_y = 2;                          // 垂直偏移2像素
    
    // 清除LOGO区域
    for(uint8_t y = 0; y < 4; y++) {  // 前4页
        for(uint8_t x = 0; x < 128; x++) {
            OLED_GRAM[y][x] = 0x00;
        }
    }
    
    // 跳过头部6字节，从第7字节开始是实际图像数据
    const uint8_t* logo_data = &gImage_minyerlogo[6];
    
    // 计算每行的字节数（按8位对齐）
    uint16_t bytes_per_row = (logo_width + 7) / 8;  // 115像素需要15个字节
    
    // 逐行解析LOGO数据
    for(uint16_t row = 0; row < logo_height; row++) {
        for(uint16_t col = 0; col < bytes_per_row; col++) {
            uint8_t data_byte = logo_data[row * bytes_per_row + col];
            
            // 每个字节表示8个像素点
            for(uint8_t bit = 0; bit < 8; bit++) {
                uint16_t pixel_x = logo_x + col * 8 + bit;
                uint16_t pixel_y = logo_y + row;
                
                // 检查是否超出屏幕或LOGO边界
                if(pixel_x >= 128 || pixel_y >= 64 || (col * 8 + bit) >= logo_width) {
                    continue;
                }
                
                // 判断该像素是否点亮（MSB first，即最高位先）
                if(data_byte & (0x80 >> bit)) {
                    // 点亮像素，设置GRAM对应位
                    OLED_GRAM[pixel_y / 8][pixel_x] |= (1 << (pixel_y % 8));
                } else {
                    // 熄灭像素，清除GRAM对应位
                    OLED_GRAM[pixel_y / 8][pixel_x] &= ~(1 << (pixel_y % 8));
                }
            }
        }
    }
    
    // LOGO显示完成，无需调试信息
}

// 显示自检进度条和公司LOGO（使用脏区刷新，避免闪烁）
void OLED_ShowSelfTestBarWithCompanyLogo(uint8_t percent)
{
    static uint8_t last_percent = 255;  // 记录上次的百分比，255表示首次调用
    static uint8_t logo_initialized = 0;  // LOGO是否已初始化
    
    // 处理重置信号（percent == 255）
    if(percent == 255) {
        last_percent = 255;
        logo_initialized = 0;
        return;  // 重置完成，直接返回
    }
    
    // 首次调用时，清屏并显示LOGO
    if(last_percent == 255) {
        OLED_Clear();
        logo_initialized = 0;
        last_percent = 0;
    }
    
    // 显示公司LOGO（只在首次或LOGO未初始化时显示）
    if(!logo_initialized) {
        OLED_ShowCompanyLogo();
        
        // 标记LOGO区域为脏区，确保刷新到屏幕
        OLED_AddDirtyRegion(0, 0, 128, 4);  // LOGO区域（前4页）
        
        logo_initialized = 1;
        
        // 绘制进度条边框（简化设计：进度条位于第5页，Y=40~47）
        uint8_t bar_page = 5;  // 进度条位于第5页
        uint8_t bar_x_start = 16;
        uint8_t bar_x_end = 111;
        
        // 绘制进度条边框（矩形边框）
        // 上边框
        for(uint8_t x = bar_x_start; x <= bar_x_end; x++) {
            OLED_GRAM[bar_page][x] |= 0x01;  // 第5页的最低位（Y=40）
        }
        
        // 下边框
        for(uint8_t x = bar_x_start; x <= bar_x_end; x++) {
            OLED_GRAM[bar_page][x] |= 0x80;  // 第5页的最高位（Y=47）
        }
        
        // 左边框
        for(uint8_t y_bit = 0; y_bit <= 7; y_bit++) {
            OLED_GRAM[bar_page][bar_x_start] |= (1 << y_bit);
        }
        
        // 右边框
        for(uint8_t y_bit = 0; y_bit <= 7; y_bit++) {
            OLED_GRAM[bar_page][bar_x_end] |= (1 << y_bit);
        }
    }
    
    // 只有进度变化时才更新进度条和百分比
    if(percent != last_percent) {
        uint8_t bar_page = 5;  // 进度条位于第5页
        uint8_t bar_x_start = 16;
        uint8_t bar_x_end = 111;
        
        // 清除进度条内部区域（保留边框）
        for(uint8_t x = bar_x_start + 1; x < bar_x_end; x++) {
            OLED_GRAM[bar_page][x] &= 0x81;  // 只保留最高位和最低位（上下边框）
        }
        
        // 填充新的进度条
        uint8_t bar_len = (uint8_t)((percent * (bar_x_end - bar_x_start - 1)) / 100); // 进度条长度
        for(uint8_t x = bar_x_start + 1; x < bar_x_start + 1 + bar_len; x++) {
            if(x < bar_x_end) {
                OLED_GRAM[bar_page][x] |= 0x7E;  // 填充中间6位（Y=41~46）
            }
        }
        
        // 清除原百分比显示区域（第7页）
        for(uint8_t x = 0; x < 128; x++) {
            OLED_GRAM[7][x] = 0x00;
        }
        
        // 显示新的百分比
        char percent_str[8];
        sprintf(percent_str, "%d%%", percent);
        uint8_t str_len = strlen(percent_str);
        uint8_t str_width = str_len * 6;
        uint8_t text_x = (128 - str_width) / 2;  // 居中显示
        
        // 显示百分比文字在第7页（Y=56~63）
        for(uint8_t i = 0; i < str_len && (text_x + i * 6) < 128; i++) {
            char c = percent_str[i];
            if(c >= 0x20 && c <= 0x7E) {
                uint8_t idx = c - 0x20;
                for(uint8_t j = 0; j < 6; j++) {
                    uint8_t x_pos = text_x + i * 6 + j;
                    if(x_pos < 128) {
                        OLED_GRAM[7][x_pos] = Font6x8[idx][j];  // 第7页显示百分比
                    }
                }
            }
        }
        
        // 标记脏区：进度条区域和百分比区域
        OLED_AddDirtyRegion(16, bar_page, 96, 1);  // 进度条区域
        OLED_AddDirtyRegion(0, 7, 128, 1);         // 百分比区域
        
        last_percent = percent;
    }
    
    // 只刷新脏区
    OLED_RefreshDirtyRegions();
}

// 重置自检进度条的状态（用于切换到第二个进度条时）
void OLED_ResetSelfTestBarState(void)
{
    // 通过特殊值255触发重置
    OLED_ShowSelfTestBarWithCompanyLogo(255);
}

// ========== OLED_DrawString字体显示函数 =============
// 支持6x8和8x16两种字体，默认使用6x8字体，8x16字体作为备用
// x:起始列，y:起始页，str:字符串，fontSize:字体大小(6或8)
void OLED_DrawString(uint8_t x, uint8_t y, const char* str, uint8_t fontSize)
{
    while(*str)
    {
        if(fontSize == 6) // 6x8字体
        {
            if(*str >= 0x20 && *str <= 0x7E && x < 128 && y < 8)
            {
                uint8_t idx = *str - 0x20;
                for(uint8_t i=0; i<6 && (x+i)<128; i++)
                {
                    OLED_GRAM[y][x+i] = Font6x8[idx][i];
                }
            }
            x += 6;
            if(x >= 128) break; // 超出屏幕宽度，停止显示
        }
        else if(fontSize == 8) // 8x16字体
        {
            if(*str >= 0x20 && *str <= 0x7E && x < 128 && y < 7) // y<7确保y+1不越界
            {
                uint8_t idx = *str - 0x20;
                for(uint8_t i=0; i<8 && (x+i)<128; i++)
                {
                    OLED_GRAM[y][x+i] = Font8x16[idx][i];
                    OLED_GRAM[y+1][x+i] = Font8x16[idx][i+8];
                }
            }
            x += 8;
            if(x >= 128) break; // 超出屏幕宽度，停止显示
        }
        str++;
    }
    OLED_Refresh();
}

/**
  * @brief  智能显示主界面（只有内容变化时才刷新）
  * @param  alarm: 报警信息
  * @param  status1: 通道1状态
  * @param  status2: 通道2状态  
  * @param  status3: 通道3状态
  * @param  tempInfo: 温度信息
  * @param  fanInfo: 风扇信息
  * @retval 无
  * @note   相比OLED_ShowMainScreen，此函数添加了内容变化检测，避免不必要的刷新
  */
void OLED_ShowMainScreenSmart(const char* alarm, const char* status1, const char* status2, const char* status3, const char* tempInfo, const char* fanInfo)
{
    // 构建当前显示内容字符串
    char current_content[DISPLAY_CACHE_SIZE] = {0};
    snprintf(current_content, sizeof(current_content), "%s|%s|%s|%s|%s|%s", 
             alarm ? alarm : "System Normal",
             status1 ? status1 : "",
             status2 ? status2 : "",
             status3 ? status3 : "",
             tempInfo ? tempInfo : "",
             fanInfo ? fanInfo : "");
    
    // 检查内容是否发生变化
    if(g_cache_valid && strcmp(current_content, g_display_cache) == 0) {
        // 内容未变化，直接返回，不刷新屏幕
        return;
    }
    
    // 内容发生变化，更新缓存并使用脏区刷新
    strncpy(g_display_cache, current_content, sizeof(g_display_cache) - 1);
    g_display_cache[sizeof(g_display_cache) - 1] = '\0';
    g_cache_valid = 1;
    
    // 调用脏区刷新机制，避免闪烁
    OLED_ShowMainScreenDirty(alarm, status1, status2, status3, tempInfo, fanInfo);
}

/**
  * @brief  强制刷新显示（忽略缓存，强制更新屏幕）
  * @retval 无
  * @note   用于需要强制刷新的场景，如系统状态切换时
  */
void OLED_ForceRefresh(void)
{
    // 清除缓存有效标志，强制下次刷新
    g_cache_valid = 0;
}

/**
  * @brief  重置显示缓存
  * @retval 无
  * @note   用于系统初始化或状态切换时重置显示缓存
  */
void OLED_ResetDisplayCache(void)
{
    memset(g_display_cache, 0, sizeof(g_display_cache));
    g_cache_valid = 0;
}

/**
  * @brief  显示主界面（三分区布局，兼容接口）
  * @param  alarm: 报警信息
  * @param  status1: 通道1状态
  * @param  status2: 通道2状态  
  * @param  status3: 通道3状态
  * @param  tempInfo: 温度信息
  * @param  fanInfo: 风扇信息
  * @retval 无
  * @note   保持向后兼容的接口，直接调用智能刷新版本
  */
void OLED_ShowMainScreen(const char* alarm, const char* status1, const char* status2, const char* status3, const char* tempInfo, const char* fanInfo)
{
    // 直接调用智能刷新版本
    OLED_ShowMainScreenSmart(alarm, status1, status2, status3, tempInfo, fanInfo);
}

/**
  * @brief  显示英文字符串（默认6x8字体）
  * @param  x: 起始列坐标
  * @param  y: 起始页坐标  
  * @param  str: 要显示的字符串
  * @retval 无
  * @note   这是OLED_DrawString的简化版本，默认使用6x8字体
  */
void OLED_DrawString6x8(uint8_t x, uint8_t y, const char* str)
{
    OLED_DrawString(x, y, str, FONT_SIZE_6X8);
}

/**
  * @brief  显示英文字符串（8x16字体，备用）
  * @param  x: 起始列坐标
  * @param  y: 起始页坐标  
  * @param  str: 要显示的字符串
  * @retval 无
  * @note   这是OLED_DrawString的简化版本，使用8x16字体（备用）
  */
void OLED_DrawString8x16(uint8_t x, uint8_t y, const char* str)
{
    OLED_DrawString(x, y, str, FONT_SIZE_8X16);
}

/**
  * @brief  添加脏区记录
  * @param  x: 起始X坐标
  * @param  y: 起始Y坐标（页）
  * @param  w: 宽度
  * @param  h: 高度（页数）
  * @retval 无
  */
void OLED_AddDirtyRegion(uint8_t x, uint8_t y, uint8_t w, uint8_t h)
{
    // 边界检查
    if(x >= 128 || y >= 8 || w == 0 || h == 0) return;
    if(x + w > 128) w = 128 - x;
    if(y + h > 8) h = 8 - y;
    
    // 查找空闲脏区槽位
    for(uint8_t i = 0; i < OLED_DIRTY_REGION_MAX; i++) {
        if(!g_dirty_regions[i].is_valid) {
            g_dirty_regions[i].x_start = x;
            g_dirty_regions[i].y_start = y;
            g_dirty_regions[i].width = w;
            g_dirty_regions[i].height = h;
            g_dirty_regions[i].is_valid = 1;
            g_dirty_count++;
            return;
        }
    }
    
    // 如果没有空闲槽位，尝试合并相邻区域
    // 简化处理：直接标记全屏刷新
    if(g_dirty_count >= OLED_DIRTY_REGION_MAX) {
        OLED_ClearDirtyRegions();
        OLED_AddDirtyRegion(0, 0, 128, 8);  // 全屏标记为脏区
    }
}

/**
  * @brief  清除所有脏区记录
  * @retval 无
  */
void OLED_ClearDirtyRegions(void)
{
    memset(g_dirty_regions, 0, sizeof(g_dirty_regions));
    g_dirty_count = 0;
}

/**
  * @brief  只刷新脏区到OLED显示器
  * @retval 无
  * @note   只更新发生变化的区域，避免全屏刷新造成的闪烁
  */
void OLED_RefreshDirtyRegions(void)
{
    if(g_dirty_count == 0) return;  // 没有脏区，直接返回
    
    // 逐个刷新脏区
    for(uint8_t i = 0; i < OLED_DIRTY_REGION_MAX; i++) {
        if(!g_dirty_regions[i].is_valid) continue;
        
        DirtyRegion_t* region = &g_dirty_regions[i];
        
        // 逐页刷新脏区
        for(uint8_t page = 0; page < region->height; page++) {
            uint8_t current_page = region->y_start + page;
            if(current_page >= 8) break;
            
            // 设置页地址
            OLED_WriteCmd(0xB0 + current_page);
            // 设置列地址
            OLED_WriteCmd(0x00 + (region->x_start & 0x0F));  // 低4位
            OLED_WriteCmd(0x10 + ((region->x_start >> 4) & 0x0F));  // 高4位
            
            // 发送脏区这一页的数据
            for(uint8_t col = 0; col < region->width; col++) {
                uint8_t x_pos = region->x_start + col;
                if(x_pos >= 128) break;
                OLED_WriteData(OLED_GRAM[current_page][x_pos]);
            }
        }
        
        // 标记该脏区已处理
        g_dirty_regions[i].is_valid = 0;
    }
    
    // 清除脏区计数
    g_dirty_count = 0;
    
    // 备份当前GRAM用于下次比较
    memcpy(g_prev_gram, OLED_GRAM, sizeof(OLED_GRAM));
}

/**
  * @brief  脏区字符串显示（不立即刷新）
  * @param  x: 起始列坐标
  * @param  y: 起始页坐标  
  * @param  str: 要显示的字符串
  * @param  fontSize: 字体大小
  * @retval 无
  * @note   只更新GRAM，不立即刷新到屏幕，需要调用OLED_RefreshDirtyRegions刷新
  */
void OLED_DrawStringDirty(uint8_t x, uint8_t y, const char* str, uint8_t fontSize)
{
    uint8_t start_x = x;
    uint8_t char_count = 0;
    
    while(*str && char_count < 50) {  // 限制最大字符数，防止越界
        if(fontSize == 6) // 6x8字体
        {
            if(*str >= 0x20 && *str <= 0x7E && x < 128 && y < 8)
            {
                uint8_t idx = *str - 0x20;
                for(uint8_t i=0; i<6 && (x+i)<128; i++)
                {
                    OLED_GRAM[y][x+i] = Font6x8[idx][i];
                }
            }
            x += 6;
            if(x >= 128) break;
        }
        else if(fontSize == 8) // 8x16字体
        {
            if(*str >= 0x20 && *str <= 0x7E && x < 128 && y < 7)
            {
                uint8_t idx = *str - 0x20;
                for(uint8_t i=0; i<8 && (x+i)<128; i++)
                {
                    OLED_GRAM[y][x+i] = Font8x16[idx][i];
                    OLED_GRAM[y+1][x+i] = Font8x16[idx][i+8];
                }
            }
            x += 8;
            if(x >= 128) break;
        }
        str++;
        char_count++;
    }
    
    // 添加脏区（覆盖整个字符串显示区域）
    uint8_t width = x - start_x;
    uint8_t height = (fontSize == 8) ? 2 : 1;  // 8x16字体占2页，6x8字体占1页
    
    if(width > 0) {
        OLED_AddDirtyRegion(start_x, y, width, height);
    }
}

/**
  * @brief  脏区刷新主界面（真正无闪烁的解决方案）
  * @param  alarm: 报警信息
  * @param  status1: 通道1状态
  * @param  status2: 通道2状态  
  * @param  status3: 通道3状态
  * @param  tempInfo: 温度信息
  * @param  fanInfo: 风扇信息
  * @retval 无
  * @note   使用脏区刷新机制，只更新变化的区域，彻底解决闪烁问题
  */
void OLED_ShowMainScreenDirty(const char* alarm, const char* status1, const char* status2, const char* status3, const char* tempInfo, const char* fanInfo)
{
    // 清除之前的脏区记录
    OLED_ClearDirtyRegions();
    
    // 清除各个显示区域（只在GRAM中清除，不发送到屏幕）
    // 第一分区：报警信息区（第0行）
    for(uint8_t x = 0; x < 128; x++) {
        OLED_GRAM[0][x] = 0x00;
    }
    
    // 第二分区：三通道状态区（第2、3、4行）
    for(uint8_t y = 2; y <= 4; y++) {
        for(uint8_t x = 0; x < 128; x++) {
            OLED_GRAM[y][x] = 0x00;
        }
    }
    
    // 第三分区：温度和风扇信息区（第6、7行）
    for(uint8_t y = 6; y <= 7; y++) {
        for(uint8_t x = 0; x < 128; x++) {
            OLED_GRAM[y][x] = 0x00;
        }
    }
    
    // 标记清除的区域为脏区
    OLED_AddDirtyRegion(0, 0, 128, 1);  // 第0行
    OLED_AddDirtyRegion(0, 2, 128, 3);  // 第2-4行
    OLED_AddDirtyRegion(0, 6, 128, 2);  // 第6-7行
    
    // 绘制新内容（使用脏区绘制函数）
    // 第一分区：报警信息区
    if(alarm && strlen(alarm) > 0) {
        OLED_DrawStringDirty(0, 0, alarm, FONT_SIZE_6X8);
    } else {
        OLED_DrawStringDirty(0, 0, "System Normal", FONT_SIZE_6X8);
    }
    
    // Flash健康度显示（在报警信息行右侧）
    if(oled_show_flash_warning && LogSystem_IsInitialized()) {
        uint8_t health = LogSystem_GetHealthPercentage();
        char health_str[16];
        snprintf(health_str, sizeof(health_str), "F:%d%%", health);
        OLED_DrawStringDirty(88, 0, health_str, FONT_SIZE_6X8);  // 右上角显示
    }
    
    // 第二分区：三通道状态区（居中显示）
    if(status1) {
        // 计算居中位置：屏幕宽度128像素，6x8字体每字符6像素
        uint8_t str_len1 = strlen(status1);
        uint8_t str_width1 = str_len1 * 6;  // 6x8字体宽度
        uint8_t center_x1 = (128 - str_width1) / 2;  // 居中X坐标
        OLED_DrawStringDirty(center_x1, 2, status1, FONT_SIZE_6X8);
    }
    if(status2) {
        // 计算居中位置
        uint8_t str_len2 = strlen(status2);
        uint8_t str_width2 = str_len2 * 6;  // 6x8字体宽度
        uint8_t center_x2 = (128 - str_width2) / 2;  // 居中X坐标
        OLED_DrawStringDirty(center_x2, 3, status2, FONT_SIZE_6X8);
    }
    if(status3) {
        // 计算居中位置
        uint8_t str_len3 = strlen(status3);
        uint8_t str_width3 = str_len3 * 6;  // 6x8字体宽度
        uint8_t center_x3 = (128 - str_width3) / 2;  // 居中X坐标
        OLED_DrawStringDirty(center_x3, 4, status3, FONT_SIZE_6X8);
    }
    
    // 第三分区：温度和风扇信息区
    if(tempInfo) {
        OLED_DrawStringDirty(0, 6, tempInfo, FONT_SIZE_6X8);
    }
    if(fanInfo) {
        OLED_DrawStringDirty(0, 7, fanInfo, FONT_SIZE_6X8);
    }
    
    // 只刷新脏区到屏幕
    OLED_RefreshDirtyRegions();
}




